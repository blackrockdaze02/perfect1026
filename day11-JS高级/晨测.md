### 12.21晨测
- 谈一谈进程和线程
    进程：程序的一次执行, 它占有一片独有的内存空间

    线程： 进程内的一个独立单元，CPU的基本调度单位, 是程序执行的一个完整流程


    进程和线程特点：
        一个进程中一般至少有一个运行的线程: 主线程
        一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的
        一个进程内的数据可以供其中的多个线程直接共享
        多个进程之间的数据是不能直接共享的

- 谈一谈事件轮询
    事件循环模型/事件轮询机制（Event Loop）：
    1.代码分类：
        - 初始化代码（同步代码）：for循环等、绑定事件、设置定时器、发送ajax请求
        - 回调执行代码（异步代码）：事件回调函数、定时器回调函数、ajax请求回调函数
    
    2.代码执行顺序：
        - 先执行同步代码
        - 再执行异步代码

    3.事件模型的两个内容
        - 浏览器的事件管理模块（DOM事件管理模块、AJAX管理模块、定时器管理模块）
        - 回调队列

    4.事件轮询
        - 执行初始化代码，并把异步回调函数交给对应的事件管理模块
        - 事件发生的时候，事件管理模块会把对应的函数和数据交给 回调队列
        - 初始化代码执行完成之后，会遍历回调队列中的函数并执行

- 手写节流(基本注释)
    //节流函数(高阶函数)
    function throttle(fn, time) {
        //绑定事件的时候，先初始化一个上一次的事件
        var lastTime = 0;
        //这个函数是事件触发的时候真正调用的事件函数
        return function () {
            //这个函数就负责书写看门狗，当允许通过的时候 再调用真正的逻辑代码move
            var nowTime = Date.now();
            if (nowTime - lastTime < time) {
                return;
            }
            lastTime = nowTime;

            //arguments所在的函数就是真正的事件函数，所以拥有实参event  把event事件对象传递给fn move中就可以使用event事件对象了
            // fn(arguments[0]);
            //改变了fn的this为事件触发的对象
            fn.call(this, arguments[0])
        }
    }

- 手写防抖(基本注释)
    function debounce(fn, time) {
        var timer = null;
        //事件函数
        return function () {
            //每次触发的时候，先把上一次的计时器清掉，然后重新开始计时
            clearTimeout(timer)
            //在计时器中 arguments是不符合的，需要使用这个位置的arguments，需要保存起来
            var arg = arguments;
            //保存外边的this 在计时器函数中使用
            var that = this;
            //每次触发事件，先不执行，要延迟一定的事件再执行
            timer = setTimeout(function () {
                fn.call(that, arg[0]);
            }, time)
        }
    }

- 手写快排(基本注释)
    function quickSort(arr) {
        //先判断类型
        if (checkType(arr) !== "array") {
            return;
        }

        //判断数组的长度，如果数组长度为小于等于1，则直接把当前数组返回
        if (arr.length <= 1) {
            return arr;
        }

        //基准值选任意即可，一般选择中间值，找到中间值，并从原数组中取出中间值
        var center = arr.splice(Math.floor(arr.length / 2), 1);

        // 定义左侧和右侧的新数组， 用来存放比较后的值
        var left = [];
        var right = [];

        //比较并存放数组
        arr.forEach(function (item, index) {
            //如果当前值小于基准值，则把当前值插入到左侧数组中
            if (item <= center) {
                left.push(item)
            } else {
                right.push(item)
            }
        })
        // console.log(left, right)
        var newArr = [].concat(quickSort(left), center, quickSort(right))


        return newArr;
    }


- 作业提交地址
https://wss.pet/s/49yrxvkjbe6
