### 12.18晨测
- 谈一谈作用域链
    - 函数创建的时候，会创建一个包含全局变量对象的作用域链（scope chain），作用域链是保证对 执行环境有权访问的所有变量和函数 的有序访问
    - 函数执行的时候，会创建自身的变量对象，把当前变量对象插入到 声明函数时候生成的作用域链顶端，完成整个作用域链
    - 作用域链的顶端一定是当前执行环境的变量对象，作用域链末端一定是全局环境的变量对象window
    - 使用变量的时候会沿着作用域链一级一级的寻找，直到找到为止，如果找不到则报错

- 谈一谈变量对象
    1.当执行上下文开启的时候，变量对象就会被激活，激活以后，作用域才能使用变量
    2.变量对象和执行上下文相关，所以分为了 全局的变量对象和局部的变量对象
    3.全局的变量是都window的属性和方法，所以全局的变量对象就是window
    4.进入局部执行上下文，首先要生成一个变量对象，保存当前局部作用域中所有的变量（形参、声明的变量、声明的函数）
    5.变量对象第一步先确定形参和实参
    6.然后确定执行上下文中声明的函数,如果和形参同名，则完全覆盖
    7.确定执行上下文中声明的变量,如果变量和形参或函数同名，则变量在赋值之前不会干扰同名形参和函数
    8.以后在执行上下文中，如果使用变量 则直接去变量对象中查找即可

- 谈一谈执行上下文
    1.JS引擎并非逐行解析，而是一段段的分析和执行。这个分析，就是执行一段代码之前的准备工作,这个准备工作被称作为'执行上下文'，执行上下文其实也在内存中开辟了一块空间。
                
    2.JS可执行的代码段分为3种类型：1.全局 2.局部（函数） 3.eval()(不用)

    3.每执行一段代码，都会创建相对应的执行上下文，全局被称为全局执行上下文，局部被称为局部执行上下文

    4.因为执行上下文很多，所以还有一个执行上下文栈来负责管理所有的执行上下文

    5.代码最开始运行，首先执行的是全局执行上下文，所以会在栈中压入一个全局执行上下文，等待页面运行结束，才会弹出

    6.只要执行一个函数，会创建一个局部执行上下文并压栈，当函数执行完成以后，就会把局部执行上下文从栈里弹出

    7.准备工作：1.变量对象  2.作用域链  3.this

- 画终极原型图

- 谈一谈显式原型和隐式原型：
    每一个函数都有一个prototype属性，即显式原型
        - 函数的prototype在创建函数的时候自动添加上，在访问实例化对象的属性的时候可能使用
    每一个对象都有一个__proto__属性，即隐式原型
        - __proto__在实例化对象的时候添加，指向构造函数的prototype，当获取对象上的属性或方法找不到的时候，会自动调用__proto__
    对象的隐式原型指向其所在构造函数的显式原型

- 手写instanceof
    function myInstanceof(A, B) {
        var BPro = B.prototype;
        var startA = A.__proto__;

        //如果while条件达不到，则说明B不在A的原型链上 返回false
        while (startA) {
            if (startA === BPro) {
                return true;
            }
            //每次要获取上一级的原型对象
            startA = startA.__proto__;
        }

        return false;
    }


作业提交地址：
https://wss.pet/s/493t2rrekdk